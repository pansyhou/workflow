#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MaxQueueSize 100
#define ArrayLenth 100
//1.?????ŽG??
typedef struct BiTreeNode
{
	//???????????????
	char data;
	int NodeDepth;//??????
	struct BiTreeNode *leftChild;
	struct BiTreeNode *rightChild;
}BiTreeNode;

//2.?????
void Initiate(BiTreeNode **root,char x){
//?????????????????????
	*root = (BiTreeNode *)malloc(sizeof(BiTreeNode));
	(*root)->data = x;
	(*root)->NodeDepth = 0;//?????????0
	(*root)->leftChild = NULL;
	(*root)->rightChild = NULL;
}

//3.???????
//???????curr????????curr?????????????????x??????
//?curr??????????????????????????????
//??????????????????????????????????
BiTreeNode *InsertLeftNode(BiTreeNode *curr,char x)
{
	BiTreeNode *s,*t;
	if(curr == NULL)return NULL;
	t = curr->leftChild;		//?????curr????????????????
	s = (BiTreeNode *)malloc(sizeof(BiTreeNode));
	s->data = x;
	s->leftChild = t;		//????????????????curr????????
	s-> rightChild = NULL;
	curr->leftChild = s;//??????curr????????
	s->NodeDepth = curr->NodeDepth+1;//??????????????+1
	return curr->leftChild;//???????????????
}

//4.???????
//???????curr????????curr?????????????????x??????
//?curr??????????????????????????????
//??????????????????????????????????
BiTreeNode *InsertRightNode(BiTreeNode *curr,char x)
{
	BiTreeNode *s,*t;
	if(curr == NULL)return NULL;
	t = curr->rightChild;		//?????curr????????????????
	s = (BiTreeNode *)malloc(sizeof(BiTreeNode));
	s->data = x;
	s->rightChild = t;		//????????????????curr????????
	s-> leftChild = NULL;
	curr->rightChild = s;   //??????curr????????
	s->NodeDepth = curr->NodeDepth+1;//??????????????+1
	return curr->rightChild;//???????????????
}

//??????????
void Destroy(BiTreeNode **root)
{
	if((*root) != NULL &&(*root)->leftChild != NULL)
		Destroy(&(*root)->leftChild);
	if((*root) != NULL &&(*root)->rightChild != NULL)
		Destroy(&(*root)->rightChild);
	free(*root);
}

//5.?????????
//??curr?????????curr?????????????
//???????????????????????????????????????
BiTreeNode *DeleteLeftTree(BiTreeNode **curr)
{
	if(*curr == NULL || (*curr)->leftChild == NULL)return NULL;
	Destroy(&(*curr)->leftChild);
	(*curr)->leftChild = NULL;
	return *curr;
}

//6.?????????
//??curr?????????curr????????????? 
//???????????????????????????????????????
BiTreeNode *DeleteRightTree(BiTreeNode **curr)
{
	if(*curr == NULL || (*curr)->rightChild == NULL)return NULL;
	Destroy(&(*curr)->rightChild);
	(*curr)->rightChild = NULL;
	return *curr;
}


//??§Õprint???????????
void print(char x)
{
	printf("%c",x);
}

//??????????????????????visit()????
void PreOrder(BiTreeNode *root, void visit(char x))
{
	if(root != NULL)
	{
		visit(root->data);
		PreOrder(root->leftChild,visit);
		PreOrder(root->rightChild,visit);
	}
}

//???????????????????????visit()????
void InOrder(BiTreeNode *root, void visit(char x))
{
	if(root != NULL)
	{
		InOrder(root->leftChild,visit);
		visit(root->data);
		InOrder(root->rightChild,visit);
	}
}

//???????????????????????visit()????
void PostOrder(BiTreeNode *root, void visit(char x))
{
	if(root != NULL)
	{
		PostOrder(root->leftChild,visit);
		PostOrder(root->rightChild,visit);
		visit(root->data);
	}
}

//???????§µ?????????????????
typedef struct SeqCQueue
{
	BiTreeNode *root[MaxQueueSize];
	int rear;//??¦Â???
	int front;//??????
	int count;//??????
}SeqCQueue;
//???§Ô????
void QueueInitiate(SeqCQueue *Q)
{
	int i;
	for(i = 0;i < MaxQueueSize;i++){
		Q->root[i] = NULL;
	}
	Q->rear = 0;
	Q->front = 0;
	Q->count = 0;
}
//?§Ø??????????
int QueueNotEmpty(SeqCQueue *Q)
{
	if(Q->count != 0)
	{	
		return 1;
	}
	else {
		return 0;
	}
}
//??????
int QueueAppend(SeqCQueue *Q,BiTreeNode *root)
{
	if(Q->count > 0 && Q->rear == Q->front)//??????
	{
		return 0;
	}
	else{
		Q->root[Q->rear] = root;//??????root????????¦Â
		Q->rear = (Q->rear +1) % MaxQueueSize;//??¦Â??????1
		Q->count++;//????????1
		return 1;
	}
}
//???????
BiTreeNode *QueueDelete(SeqCQueue *Q)
{
	if(Q->count == 0)//???§á?
	{
		return NULL;
	}
	else
	{
		BiTreeNode *d;
		d = Q->root[Q->front];//???????????????d??
		Q->front = (Q->front + 1) % MaxQueueSize;//?????????1
		Q->count--;//????????1
		return d;
	}
}

//?????????,????????visit()????
void SeqOrder(BiTreeNode *root,void visit(char x))
{
	SeqCQueue queue;  //????????
	SeqCQueue *Q = &queue;
	QueueInitiate(Q);  //???§Ô????
	QueueAppend(Q,root); //??????????????
	while(QueueNotEmpty(Q)){  //???????????????
		BiTreeNode *t;		//t????????????????
		t = QueueDelete(Q);  //?????????????
		visit(t->data);    //???visit?????????????
		if(t->leftChild != NULL)
		{
			//???????????????????
			//??????????????????
			if(!(QueueAppend(Q,t->leftChild)))
			{
				//??????§á???????????????????
				printf("\n?????????????§á????????????\n");
				break;
			}
		}
		if(t->rightChild != NULL)
		{
			//???????????????????
			//??????????????????
			if(!(QueueAppend(Q,t->rightChild)))
			{
				//??????§á???????????????????
				printf("\n?????????????§á????????????\n");
				break;
			}
		}
	}
}

//?????????(??????????????????0)
	//??§Õ???????????¦Å????
void RecordDepth(int NodeDepth,int *BiTreeDepth){
	if(NodeDepth > *BiTreeDepth){
		*BiTreeDepth = NodeDepth;//??????????????
	}
}	
	//?????????BiTreeDepth
void PreOrderFindBiTreeDepth(BiTreeNode *root, void visit(int NodeDepth,int *BiTreeDepth),int *BiTreeDepth)
{
	if(root != NULL)
	{
		visit(root->NodeDepth,BiTreeDepth);
		PreOrderFindBiTreeDepth(root->leftChild,visit,BiTreeDepth);
		PreOrderFindBiTreeDepth(root->rightChild,visit,BiTreeDepth);
	}
}
	//?????????????
int GetBiTreeDepth(BiTreeNode *root){
	int BiTreeDepth = 0;
	PreOrderFindBiTreeDepth(root,RecordDepth,&BiTreeDepth);
	return BiTreeDepth;
}

//???????????????????
	//????????????§Õ???
void PrinfLeafNodeAndNonLeafNode(BiTreeNode *root)
{
	char LeafNode[ArrayLenth];
	char NonLeafNode[ArrayLenth];
	int i;
	SeqCQueue queue;  //????????
	SeqCQueue *Q = &queue;
	QueueInitiate(Q);  //???§Ô????
	QueueAppend(Q,root); //??????????????
	while(QueueNotEmpty(Q))
	{  //???????????????
		BiTreeNode *t;		//t????????????????
		t = QueueDelete(Q);  //?????????????
		if(t->leftChild == NULL && t->rightChild == NULL){
			LeafNode[strlen(LeafNode)] = t->data;
		}else{
			NonLeafNode[strlen(NonLeafNode)] = t->data;
		}
		if(t->leftChild != NULL)
		{
			//???????????????????
			//??????????????????
			if(!(QueueAppend(Q,t->leftChild)))
			{
				//??????§á???????????????????
				printf("\n?????????????§á????????????\n");
				break;
			}
		}
		if(t->rightChild != NULL)
		{
			//???????????????????
			//??????????????????
			if(!(QueueAppend(Q,t->rightChild)))
			{
				//??????§á???????????????????
				printf("\n?????????????§á????????????\n");
				break;
			}
		}
	}
	//????????????
	printf("??????????§µ?");
	for (i = 0; i < strlen(LeafNode); i++)
	{
		printf("%c",LeafNode[i]);
	}
	printf("\n???????????§µ?");
	for (i = 0; i < strlen(NonLeafNode); i++)
	{
		printf("%c",NonLeafNode[i]);
	}
}